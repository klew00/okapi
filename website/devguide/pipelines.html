<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Okapi Framework Developer's Guide - Pipelines</title>
<link rel="stylesheet" type="text/css" href="../okapi.css">
</head>

<body>

<table border="0" width="100%" cellspacing="0" cellpadding="0">
	<tr class="head">
		<td class="head" colspan="2"><h1 class="head">Okapi Framework - Developer's Guide</h1>
		<h2 class="head2">Pipelines</h2></td>
	</tr>
	<tr>
		<td class="smalltoc"><p>
			- <a href="#overview">Overview</a><br/>
			- <a href="#simplePipeline">Simple Pipeline</a><br/>
			- <a href="#creatingSteps">Creating Steps</a>
		</p></td>
		<td class="hmenu">
			<div class="hmenu"><table align="right"><tr>
				<td><a href="glossary.html">Glossary</a></td>
				<td><a href="index.html">Guide Content</a></td>
				<td><a href="http://okapi.opentag.com">Okapi Framework</a></td>
			</tr></table></div>
		</td>
	</tr>
</table>

<h2><a name="overview"></a>Overview</h2>
<p>Pipelines are a powerful mechanism to apply a sequence of actions to an input 
document (or a set of them). They allow you to construct processes customized to specific projects 
very easily, re-using the same components. For example, many tasks can be broken down into these main parts:</p>
<p>Extract the text &gt;&gt; Apply some changes to the text &gt;&gt; Merge back the 
modified text into 
its original format.</p>
<p>With the framework this type of sequence is implemented using the following 
interfaces:</p>
<p><code><a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
&gt;&gt; <code><a href="../javadoc/net/sf/okapi/common/pipeline/IPipelineStep.html">
IPipelineStep</a></code> &gt;&gt; <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">
IFilterWriter</a></code></p>
<p>The pipeline is the glue that puts these parts together and allows you to include as many as you 
need.</p>
<h2><a name="simplePipeline"></a>Simple Pipeline</h2>
<p>A pipeline is represented by a <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/IPipeline.html">IPipeline</a></code> 
interface. The framework offers several implementations for it. The simplest is 
the <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/Pipeline.html">Pipeline</a></code> 
class.</p>
<pre>// Create the pipeline
IPipeline pipeline = new Pipeline();</pre>
<p>Use the classe <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/RawDocumentToEventsStep.html">
RawDocumentToEventsStep</a></code> to plug any <code>
<a href="../javadoc/net/sf/okapi/common/filters/IFilter.html">IFilter</a></code> 
objects in the pipeline, 
and the class
<code>
<a href="../javadoc/net/sf/okapi/common/pipeline/EventsToRawDocumentStep.html">
EventsToRawDocumentStep</a></code> for any <code>
<a href="../javadoc/net/sf/okapi/common/filterwriter/IFilterWriter.html">
IFilterWriter</a></code> object.</p>
<p>Creating the initial step with the filter is easy:</p>
<pre>// Create the filter we will use
IFilter filter = new HtmlFilter();
// Create the filter step
IPipelineStep filterStep = new RawDocumentToEventsStep(filter);
// Add this step to the pipeline
pipeline.addStep(filterStep);</pre>
<p>Creating the last step with the filter writer is also quite easy:</p>
<pre>// Create the writer we will use
IFilterWriter writer = filter.createFilterWriter();
// Create the writer step (using the writer provider by our filter)
IPipelineStep writerStep = new EventsToRawDocumentStep(writer);
// Add this step to the pipeline
pipeline.addStep(writerStep);</pre>
<p>Now we have a pipeline with two steps. It can reads and re-writes a given HTML 
document. To use it, you have to set the input and output options just like when 
you are not using the pipeline:</p>
<pre>// Sets the writer options and output
writer.setOptions(&quot;fr&quot;, &quot;UTF-8&quot;);
writer.setOutput(&quot;myPipelineOutput.html&quot;);</pre>
<p>Once all options are set you can one of the <code>process()</code> methods provided by 
the pipeline to execute the process. The method initiates the first call to the filter and triggers 
the flow of events that go through all the steps. Once the pipeline is not needed 
anymore, you should call <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/IPipeline.html#destroy()">
IPipeline.destroy()</a></code> to clean up any resource used by the steps:</p>
<pre>String input = &quot;&lt;html&gt;&lt;head&gt;\n&quot;
+ &quot;&lt;meta http-equiv='Content-Language' content='en'&gt;&lt;/head&gt;\n&quot;
+ &quot;&lt;body&gt;\n&quot;
+ &quot;&lt;p&gt;Text in &lt;b&gt;bold&lt;/b&gt;.&lt;/p&gt;&quot;
+ &quot;&lt;/body&gt;&lt;/html&gt;&quot;;
// Launch the execution
pipeline.process(new RawDocument(input, &quot;en&quot;));

// Clean up all the pipeline resources
pipeline.destroy();</pre>
<h2><a name="creatingSteps"></a>Creating Steps</h2>
<p dir="ltr">Now we need to add at least one step between the filter and the filter writer 
to have a useful pipeline. This requires to create a new class that implements 
the <code><a href="../javadoc/net/sf/okapi/common/pipeline/IPipelineStep.html">IPipelineStep</a></code> interface. The framework makes things easy by 
providing the class <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/BasePipelineStep.html">BasePipelineStep</a></code> that you can 
use to derive you own classes.</p>
<p>The only methods you have to implement are <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/IPipelineStep.html#getName()">
IPipelineStep.getName()</a></code> to provide 
a name to the step, and whatever handler method for the events you want to act 
upon. Most of the time it will be just <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/BasePipelineStep.html#handleTextUnit(net.sf.okapi.common.Event)">
BasePipelineSetp.handleTextUnit()</a></code>.</p>
<p dir="ltr">For example, the class below implements <code>
<a href="../javadoc/net/sf/okapi/common/pipeline/BasePipelineStep.html#handleTextUnit(net.sf.okapi.common.Event)">
BasePipelineSetp.handleTextUnit()</a></code> to 
intercept any <code>TEXT_UNIT</code> event that pass through the pipeline. Here 
we perform a mock pseudo-translation by replacing some ASCII characters by 
the same ones with accents, so the text <code>&quot;A goose quill is more dangerous 
than a lion's claw&quot;</code> becomes <code>&quot;A gõõsè qüìll ìs mõrè ðåñgèrõüs thåñ å 
lìõñ's çlåw&quot;</code>.</p>
<p>In order to create the target text in the text unit, the class needs to know what the 
target language is. So we pass that information through the class' 
constructor. Otherwise changing the text is fairly simple. See the section
<a href="gettingstarted.html#TextUnits">Working with Text Units</a> for more 
details on how to modify text units.</p>
<pre>public class PseudoTranslateStep extends BasePipelineStep {

   private static final String OLDCHARS = &quot;aeiouycdn&quot;;
   private static final String NEWCHARS = &quot;\u00e5\u00e8\u00ec\u00f5\u00fc\u00ff\u00e7\u00f0\u00f1&quot;;
   private String trgLang;

   public PseudoTranslateStep (String trgLang) {
      this.trgLang = trgLang;
   }

   public String getName () {
      return &quot;PseudoTranslateStep&quot;;
   }

   protected void handleTextUnit (Event event) {
      TextUnit tu = (TextUnit)event.getResource();
      if ( tu.isTranslatable() ) {
         TextFragment tf = tu.createTarget(trgLang, false, IResource.COPY_CONTENT);
         StringBuilder text = new StringBuilder(tf.getCodedText());
         int n;
         for ( int i=0; i&lt;text.length(); i++ ) {
            if ( TextFragment.isMarker(text.charAt(i)) ) i++; // Skip the pair
            else {
               if ( (n = OLDCHARS.indexOf(text.charAt(i))) &gt; -1 ) {
                  text.setCharAt(i, NEWCHARS.charAt(n));
               }
            }
         }
         tf.setCodedText(text.toString());
      }
   }
}</pre>
<p>Once we have defined an implementation for the step that will modify the 
extracted text, we simply need to add it between the input and output steps:</p>
<pre>// Create the step
PseudoTranslateStep pseudoTransStep = new PseudoTranslateStep(&quot;fr&quot;);
pipeline.addStep(pseudoTransStep);</pre>
<p>At first it may seems more complicated to create a new class for each new step instead 
of directly working in a single class, But the benefits are important: 
Each step defined as a separate class can be re-used easily in different processes.</p>
<p>You should see each step as a component independent of everything else. It 
should not be filter-specific and not use any global parameter. It should, most 
of the time, not expect to be before or after another specific step. It should also 
be aware of inline codes, as well as the translate and the preserve-whitespaces 
information attached to each text unit. The <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html">TextUnit</a></code> 
class may provide plenty of information you can query: <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getType()">
TextUnit.getType()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getName()">
TextUnit.getName()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getMimeType()">
TextUnit.getMimeType()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getAnnotation(java.lang.Class)">
TextUnit.getAnnotation()</a></code>, <code>
<a href="../javadoc/net/sf/okapi/common/resource/TextUnit.html#getProperty(java.lang.String)">
TextUnit.getProperty()</a></code>, etc. Make use of them to drive the different 
actions performed on the extracted text.</p>
<p>&nbsp;</p>

</body>

</html>
